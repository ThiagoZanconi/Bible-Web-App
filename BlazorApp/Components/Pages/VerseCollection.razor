@page "/collection/{name}"
@using BlazorApp.Components.Pages.CollectionsComponents
@using BlazorApp.Components.Services
@using BlazorApp.Model
@inject IBibleApiService BibleApiService
@inject Blazored.LocalStorage.ILocalStorageService localStorage

<div class="px-3">
    <p class="fs-5 fw-bold text-center p-3 rounded shadow w-full m-0" style="white-space: pre-wrap; word-wrap: break-word;">
        @name
    </p>
</div>
<div class="px-5 mt-3">
    @foreach(string chapter in ChapterVerseDictionary.Keys){
        <pre class="fs-5 fw-light text-center p-3 rounded shadow w-full mb-3" style="white-space: pre-wrap; word-wrap: break-word;">
            @chapter
        </pre>
        <div class="p-3 rounded shadow w-full fs-5 fw-light">
            @foreach(var entry in ChapterVerseDictionary[chapter]){
                <div class="text-center">
                    <button class="rounded expand-custom @(selectedVerse==entry.Key && @ShowPrevButton(chapter, entry.Key) ? "show" : "")" style="width: 180px;"
                    @onclick="() => ShowPrevVerse(chapter, entry.Key)">
                        Prev
                    </button>
                    <div class="col d-flex justify-content-between">
                        <pre class="cursor-pointer text-start underline-on-hover my-auto" style="white-space: pre-wrap; word-wrap: break-word;" 
                        @onclick="() => VerseSelected(entry.Key)" >
                            @PrintVerse(entry.Key)
                        </pre>
                        <div class="d-flex gap-2">
                            @if(entry.Value){
                                <button class="d-flex justify-content-center align-items-center rounded cancel-button mx-3" style="width: 60px; height: 60px;" 
                                @onclick="() => DeleteVerseFromCollection(chapter, entry.Key)">
                                    <img src="images/trash-can.svg" width="25" height="25" alt="Del">
                                </button>
                            }
                            else{
                                <button class="d-flex justify-content-center align-items-center rounded add-button mx-3 fs-2 fw-bold" style="width: 60px; height: 60px;" 
                                @onclick="() => SaveVerseToCollection(chapter, entry.Key)">
                                    +
                                </button>
                            }
                        </div>
                    </div>
                    <button class="rounded expand-custom @(selectedVerse==entry.Key && @ShowNextButton(chapter, entry.Key) ? "show" : "")" style="width: 180px;"
                    @onclick="() => ShowNextVerse(chapter, entry.Key)">
                        Next
                    </button>
                </div>
            }
        </div>
        <hr class="border-4 border-dark"> 
    }
</div>

<DeleteConfirmationComponent @ref="DeleteRef" ConfirmDeleteCallback="ConfirmDelete"></DeleteConfirmationComponent>
<NotificationComponent @ref="NotificationRef"></NotificationComponent>

@code{
    [Parameter]
    public string name { get; set; } = String.Empty;
    private List<Verse> verses { get; set; } = new();
    private Dictionary<string, SortedDictionary<Verse, bool>> ChapterVerseDictionary = new Dictionary<string, SortedDictionary<Verse, bool>>();
    private Verse? verseToDelete;
    private Verse? selectedVerse;
    private string? chapterContainingVerseToDelete;
    private DeleteConfirmationComponent? DeleteRef;
    private NotificationComponent? NotificationRef;
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if(firstRender){
            await FetchVerses();
            SetChapters();
            StateHasChanged();
        }
    }
    private void SetChapters(){
        //verses.Sort((a, b) => a.vrs.CompareTo(b.vrs));
        foreach(var verse in verses){

            var chapter = verse.bookId+" "+verse.chapter;
            if (!ChapterVerseDictionary.ContainsKey(chapter))
            {
                ChapterVerseDictionary[chapter] = new SortedDictionary<Verse, bool>(
                    Comparer<Verse>.Create((a, b) => a.vrs.CompareTo(b.vrs))
                );
            }
            ChapterVerseDictionary[chapter][verse] = true;
        }
    }
    private async Task FetchVerses(){
        var token = await localStorage.GetItemAsync<string>("jwtToken");
        if(token!=null){
            verses = await BibleApiService.GetVerseCollectionAsync(token,name)?? new();
        }
    }
    private string PrintVerse(Verse verse){
        string text="";
        text+=ToSuperscript(verse.vrs)+" ";
        text+=verse.text;
        return text;
    }
    private void VerseSelected(Verse verse){
        if(selectedVerse == verse){
            selectedVerse = null;
        }
        else{
            selectedVerse = verse;
        }
    }

    private bool ShowPrevButton(string chapter, Verse verse){
        if(ChapterVerseDictionary[chapter].Any(e => verse.vrs!=0 && e.Key.vrs == verse.vrs-1 )){
            return false;
        }
        else{
            return true;
        }
    }

    private bool ShowNextButton(string chapter, Verse verse){
        if(ChapterVerseDictionary[chapter].Any(e => e.Key.vrs == verse.vrs+1 )){
            return false;
        }
        else{
            return true;
        }
    }
    private async Task ShowPrevVerse(string chapter, Verse verse){
        Verse? next = await BibleApiService.GetVerseAsync(verse.bookId, verse.chapter, verse.vrs-1);
        if(next!=null){
            ChapterVerseDictionary[chapter].Add(next, false);
        }
    }
    private async Task ShowNextVerse(string chapter, Verse verse){
        Verse? next = await BibleApiService.GetVerseAsync(verse.bookId, verse.chapter, verse.vrs+1);
        if(next!=null){
            ChapterVerseDictionary[chapter].Add(next, false);
        }
    }
    private static string ToSuperscript(int number)
    {
        var superscriptDigits = new Dictionary<char, char>
        {
            { '0', '⁰' }, { '1', '¹' }, { '2', '²' }, { '3', '³' }, { '4', '⁴' },
            { '5', '⁵' }, { '6', '⁶' }, { '7', '⁷' }, { '8', '⁸' }, { '9', '⁹' }
        };

        return new string(number.ToString().Select(d => superscriptDigits[d]).ToArray());
    }
    private void DeleteVerseFromCollection(string chapter, Verse verse){
        chapterContainingVerseToDelete = chapter;
        verseToDelete = verse;
        DeleteRef?.ToggleModal();
    }

    private async void ConfirmDelete()
    {
        bool deletedCollection = await DeleteVerseRequest();
        if(deletedCollection){
            verses.Remove(verseToDelete!);
            ChapterVerseDictionary[chapterContainingVerseToDelete!].Remove(verseToDelete!);
            if(ChapterVerseDictionary[chapterContainingVerseToDelete!].Count == 0){
                ChapterVerseDictionary.Remove(chapterContainingVerseToDelete!);
            }
            StateHasChanged();
        }
    }

    private async Task<bool> DeleteVerseRequest(){
        var token = await localStorage.GetItemAsync<string>("jwtToken");
        bool toReturn = false;
        if(token!=null && verseToDelete!=null){
            toReturn = await BibleApiService.DeleteVerseFromCollectionAsync(token, name, verseToDelete.bookId, verseToDelete.chapter, verseToDelete.vrs);
        }
        NotificationRef?.notifyVerseElimination(toReturn);
        return toReturn;
    }

    private async Task SaveVerseToCollection(string chapter, Verse v){
        var token = await localStorage.GetItemAsync<string>("jwtToken");
        bool success = false;
        if(token!=null){
            success = await BibleApiService.PostVerseToCollectionAsync(token, name, v);
        }
        NotificationRef?.notifyAddition(success);
        ChapterVerseDictionary[chapter][v] = success;
        StateHasChanged(); 
    }
}